"use strict";
const url = require("url");
const path = require("path");
const got = require("got");
const findUp = require("find-up");
const pFinally = require("p-finally");

const { requestCount, requestDuration, failureCount } = require("./metrics");

const IPC_MANIFESTS_FOLDER = "ipc_manifests";

class RpcResponseError extends Error {
  constructor(source, responseBody) {
    super();

    Object.defineProperty(this, "name", {
      configurable: true,
      enumerable: false,
      value: this.constructor.name,
      writable: true,
    });

    Object.assign(this, responseBody);
    if (!this.source) this.source = [];
    this.source = [source, ...(this.source || [])];

    Object.defineProperty(this, "stack", {
      configurable: true,
      enumerable: false,
      value:
        this.toString() +
        "\n" +
        [...this.source]
          .reverse()
          .map((s) => "    via " + s)
          .join("\n"),
      writable: true,
    });
  }

  static get help() {
    return "An error generated by the response to an RPC request by the remote service. You will not typically see this error message directly as the code and type will typically be mapped through.";
  }

  toString() {
    return `${this.name}: ${this.message} [${this.instance}]`;
  }
}

/**
 *
 * @param {string} host
 * @param {string} serviceName
 * @param {Object} options
 * @param {string=} options.path
 * @returns {any}
 */
exports.load = function (host, serviceName, options) {
  const metaPath = getMetaPath(serviceName);
  const client = new LegacyClient(host, options);

  return client.load(metaPath);
};

// exports.createClient = function (host, options) {
//   return new Client(host, options);
// }

function rootModuleDir() {
  let mod = module;

  while (
    mod.parent &&
    // Hack for tests
    !mod.parent.filename.endsWith("ava/lib/worker/subprocess.js")
  ) {
    mod = mod.parent;
  }

  return path.dirname(mod.filename);
}

function getMetaPath(serviceName) {
  const fileName = path.join(IPC_MANIFESTS_FOLDER, `${serviceName}.json`);

  return (
    findUp.sync(fileName, { cwd: rootModuleDir() }) || findUp.sync(fileName)
  );
}

class LegacyClient {
  constructor(baseURL, options) {
    var parsedURL = url.parse(baseURL);
    this.protocol = parsedURL.protocol;
    this.host = parsedURL.host;
    this.port = parsedURL.port;

    Object.assign(
      this,
      {
        path: "/rpc",
      },
      options
    );
  }

  load(metaFile) {
    if (!metaFile) {
      throw new Error("invalid metaFile path");
    }

    const meta = require(metaFile);

    return this.createInterface(meta);
  }

  request(methodName, params, timeout) {
    const requestMeta = { service: this.formatUrl(), method: methodName };
    const end = requestDuration.startTimer(requestMeta);

    requestCount.inc(requestMeta);

    const requestUrl = this.formatUrl(methodName);

    const result = got
      .post(requestUrl, {
        body: JSON.stringify(params),
        headers: {
          "Content-Type": "application/json",
        },
        json: true,
        retries: 0,
        timeout,
      })
      .then((res) => res.body)
      .catch((err) => {
        failureCount.inc(
          Object.assign(
            {
              type:
                (err.response && err.response.body && err.response.body.type) ||
                undefined,
              status_code: err.statusCode,
            },
            requestMeta
          )
        );
        mapError(this.serviceName, methodName, err);
      });

    return pFinally(result, end);
  }

  formatUrl(methodName) {
    const pathname = methodName ? path.join(this.path, methodName) : this.path;

    return url.format({
      protocol: this.protocol,
      host: this.host,
      port: this.port,
      pathname: pathname,
    });
  }

  getMeta() {
    const requestUrl = this.formatUrl();

    return got(requestUrl, { json: true })
      .then((res) => res.body)
      .catch((err) => mapError(this.serviceName, "getMeta", err));
  }

  createInterface(meta) {
    this.serviceName = meta.serviceName;

    const rpcInterface = {};
    const multiArg = meta.multiArg || false;
    const self = this;

    meta.interfaces.forEach((iface) => {
      rpcInterface[iface.methodName] = function () {
        const args = Array.prototype.slice.call(arguments);
        const params = multiArg ? args : args[0];
        if (!multiArg && params && typeof params !== "object")
          throw new Error(
            "HTTP RPC expected a single arguments object, or none, simple values are not supported"
          );
        return self.request(iface.methodName, params, iface.methodTimeout);
      };
    });
    return rpcInterface;
  }
}

function mapError(serviceName, methodName, err) {
  if (err.statusCode < 500) {
    const source = `${serviceName}/${methodName}`;
    if (!err.response.body.type) {
      // Legacy
      const newErr = new Error(err.response.body.message);
      newErr.code = err.response.body.code;
      newErr.expose = err.response.body.expose;
      newErr.source = [source];
      throw newErr;
    }

    throw new RpcResponseError(source, err.response.body);
  }
  throw err;
}
